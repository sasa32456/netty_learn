Reactor模式的角色构成(一共有5个角色)

1.Handle(句柄或是描述符)：本质上表示一种资源，是由操作系统提供的；该资源表示一个个事件，比如文件描述符，或是针对网络编程中的Socket描述，事件
既可以来自于外部，也可也来自于内部；外部事件比如说客户端的连接请求，客户端发送过来的数据等；内部事件比如说操作系统产生的定时器事件等。它本质上就是一个文件
描述符。handle是事件产生的发源地。

2.Synchronous Event Demultiplexer（同步事件分离器）：它本身是一个系统调用，用于等待事件的发生（事件可能是一个，也可能是多个）。调用方在调用它的时候会
被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I/O复用机制，比如说select、poll、epoll等。在Java NIO领域中，
同步事件分离器对应的组件就是Selector；对应的方法就是select方法。

3.Event Handler（事件处理器）：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。Java NIO中无对应。Netty相比下来，在事件处理器
这个角色上进行了一个升级，它为我们开发者提供了大量的回调方法，供我们在特定事件产生时实现相对应的回调方法进行业务逻辑的处理。

4.Concrete Event Handler（具体处理器）：是事件处理器的实现（3的实现）。它本身实现了事件处理器所提供的各个回调方法，从而实现了特定业务的逻辑。他本质上就是
我们所编写的一个个处理器的实现（比如 MyServerHandler extends SimpleChannelInboundHandler<String>）。

5.Initiation Dispatcher（初始分发器）：实际上就是Reactor角色。它本身定义了一些规范，这些规范用于控制事件的调度方式，同时它又提供了应用进行事件处理器的
注册、删除等设备。它本身是整个事件处理器的核心所在，Initiation Dispatcher会通过事件分离器来等待事件的发生。一旦事件发生，Initiation Dispatcher首先会
分理出每个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。

Handle事件被Event Handler拥有，注册到Initiation Dispatcher中，同时Initiation Dispatcher开启循环，死循环通过Synchronous Event Demultiplexer等待事件发生，
当Handle产生，Synchronous Event Demultiplexer会将此事件集合反映到Initiation Dispatcher中，此时会执行select（handlers）此事件注册的处理器，从而调用Concrete Event Handler
的handle event。

Reactor 处理流程
1.当应用向Initiation Dispatcher中注册具体事件时，应用会标识出该事件需要Initiation Dispatcher在某个事件发生时向其通知该事件，该事件与Handle关联。
2.Initiation Dispatcher会要求每个事件处理器向其传递内部的handle。该Handle向系统标识了事件处理器。
3.当所有事件处理器注册完成后，应用会调用handle_event方法来启动Initiation Dispatcher循环。这时，Initiation Dispatcher会将每个注册的事件管理器的Handle合并起来，
并使用同步事件分离器等待这些事件的发生。比如说，TCP协议层会使用select同步事件分离器操作来等待客户端发送的数据到达连接的socket handle上。
4.当某个事件源对应的Handle变为ready状态时（比如说，TCP，socket变为等待读状态时），同步事件分离器就会通知Initiation Dispatcher。
5.Initiation Dispatcher会触发事件处理器的回调方法，从而响应这个处于ready状态的handle。当事件发生时，Initiation Dispatcher会将被事件源激活后的Handle作为
【key】来寻找分发恰当的事件处理器回调方法。
6.Initiation Dispatcher会回调事件处理器的handle_events回调方法来执行特定于应用的功能（开发者自己所编写的功能），从而响应这个事件。所发生的的事件类型可以作为该方法
参数并被该方法内部使用来执行额外的特定于服务的分离与分发。

